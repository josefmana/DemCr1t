#' Pre-process data for analysis
#'
#' Takes in file paths to raw data, checks their format and compatibility,
#' and if valid, proceeds to import and pre-process the data for analysis.
#' This function serves as the main entry point for assembling a clean dataset
#' from raw sources.
#'
#' @param p A named character vector of file paths generated by \code{data_paths}.
#' @param check.names A logical indicating whether \code{check_names} should be
#'    run to compare names in meta data and item data.
#'
#' @returns A tibble containing cleaned and pre-processed variables ready for analysis.
#'    The function also performs validation checks and prints warnings or stops execution
#'    if critical issues are detected (e.g., mismatched names, out-of-range values).
#'
#' @examples
#' \dontrun{
#' p <- data_paths("data-raw")
#' data <- prepare_data(p)
#' }
#'
#' @export
prepare_data <- function(p, check.names = TRUE) {
  # Read data sets:
  Scoring <- readr::read_delim(p[4], delim = ";", col_types = readr::cols(rev = "c"))
  REDCap <- import_redcap_data(p[2], Scoring)
  ItemData <- import_item_data(p[1])
  # Check names and compatibility:
  if (check.names) {
    check_names(d = ItemData, nms = readr::read_csv(p[3], show_col_types = FALSE))
  }
  disc <- check_compatibility(d1 = ItemData, d2 = REDCap)
  if (nrow(disc) > 1) {
    discfile <- here::here("temp", "discrepancies.csv")
    cat(glue::glue("\nThere were some discrepancies, REDCap data were used.\nCheck the {discfile} file to reconcile any incompatibilities.\n"))
    if (!dir.exists("temp")) {
      dir.create("temp")
    }
    readr::write_csv(disc, discfile, na = "")
  } else {
    if (dir.exists("temp")) {
      unlink("temp", recursive = TRUE)
    }
  }
  # Prepare a full data set:
  df <- ItemData |>
    dplyr::filter(incl == 1) |>
    dplyr::left_join(REDCap, by = dplyr::join_by(id), suffix = c("_iw", "_rc"))
  cv <- names(df)[grepl("_iw", names(df))] |>
    sub(x = _, "_iw", "")
  for (i in cv) {
    df[ , i] <- NA
    for (j in seq_len(nrow(df))) {
      df[j , i] <- ifelse(
        test = !is.na(df[j , paste0(i, "_rc")]),
        yes = df[j , paste0(i, "_rc")],
        no = df[j , paste0(i, "_iw")]
      )
    }
    df[ , paste0(i, "_rc")] <- NULL
    df[ , paste0(i, "_iw")] <- NULL
  }
  mist <- check_ranges(df)
  if (mist$stop) {
    for (i in names(mist$typos)) {
      if (nrow(mist$typos[[i]] != 0)) {
        print(mist$typos[i])
      }
    }
    stop("There seem to be typos, check the data listed above.")
  }
  df <- df |> dplyr::mutate(age = lubridate::time_length(difftime(assdate, birth), unit = "years"))
  # Assign cognitive impairment status based on Level II:
  calc_file <- here::here("data-raw", "LevelIICalculator.xlsx")
  map_file  <- here::here("data-raw", "CalculatorMapping.csv")
  ci_lvlII <- assign_cognitive_impairment(df, calc_file, map_file, "both")
  # Return the data:
  df |> dplyr::left_join(ci_lvlII, by = "id")
}
