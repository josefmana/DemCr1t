#' Summarise Kappa Coefficients
#'
#' Using a list of PDD algorithms stratified by IADL deficit operationalisation
#' and a table of pairwise concordance statistics, this function extracts the
#' raw Cohenâ€™s kappa estimates and computes their summary statistics (mean and
#' standard deviation) across groups of algorithm pairs defined by the IADL
#' operationalisation scheme.
#'
#' @param algorithms A list containing algorithm mapping generated by
#'    \code{list_algorithms}.
#' @param concordance A tibble containing concordance indexes for pairs
#'    of algorithms generated by \code{decribe_concordance}. The table
#'    is also available as data \link{concords}.
#'
#' @returns A list with the following components:
#' \describe{
#'   \item{\code{faq_tot}}{A numeric vector containing all Cohen's kappas
#'   of algorithm pairs with IADL deficit defined as FAQ total > 7.}
#'   \item{\code{faq_9}}{A numeric vector containing all Cohen's kappas
#'   of algorithm pairs with IADL deficit defined as FAQ item 9 > 1.}
#'   \item{\code{cross}}{A numeric vector containing all Cohen's kappas
#'   of algorithm pairs with different IADL deficit definitions.}
#'   \item{\code{iadl}}{A numeric vector containing all Cohen's kappas
#'   of algorithm pairs which differ only in IADL deficit definition.}
#'   \item{\code{sums}}{A named character vector containing mean and
#'   standard deviation of each vector of Kappas contained in this list.}
#' }
#'
#' @seealso
#' * [list_algorithms()] prepares `algorithms`.
#' * [describe_concordance()] prepares `concordance`.
#' * [concords] containg data used as `concordance`.
#'
#' @examples
#' \dontrun{
#' p <- data_paths("data-raw")
#' data <- prepare_data(p)
#' pdd  <- diagnose_pdd_sample(data)
#' vars <- here::here("data-raw", "VariablesOfInterest.csv")
#'
#' data(concords)
#' rates <- summarise_rates(pdd, vars)
#' algos <- list_algorithms(rates$table)
#'
#' # Two equally valid ways to run the function:
#' kappa1 <- summarise_kappa(algos, rates$table)
#' kappa2 <- summarise_kappa(algos, concords)
#' }
#'
#' @export
summarise_kappa <- function(algorithms, concordance) {
  # Prepare combinations within IADL operationalisation:
  k <- lapply(rlang::set_names(names(algorithms)), function(o) {
    combn(algorithms[[o]], 2) |>
      t() |>
      tibble::as_tibble() |>
      `colnames<-`(c("predictor", "reference")) |>
      dplyr::left_join(concordance, by = dplyr::join_by(predictor, reference)) |>
      dplyr::pull(Kappa_raw)
  })
  # Add cross-operationalisation cases:
  k$cross <- subset(concordance, predictor %in% algorithms$faq_9 & reference %in% algorithms$faq_tot)$Kappa_raw
  # Add Kappa summaries of algorithms with same everything but different IADL:
  k$iadl <- data.frame(
    predictor = c("Lvl.II (1)", "MMSE (1)", "MMSE (3)", paste0("MoCA (", seq(1, 59, 2),")"), "sMoCA (1)"),
    reference = c("Lvl.II (2)", "MMSE (2)", "MMSE (4)", paste0("MoCA (", seq(2, 60, 2),")"), "sMoCA (2)")
  ) |>
    dplyr::left_join(concordance, by = dplyr::join_by(predictor, reference)) |>
    dplyr::pull(Kappa_raw)
  # Extract Kappa summaries:
  k$sums <- sapply(names(k), function(i) {
    paste0(do_summary(k[[i]], 2, "M"),", SD = ", do_summary(k[[i]], 2, "SD"))
  })
  # Add summaries of Kappas:
  k$sums["iadl"] <- paste0(do_summary(k$iadl, 2, "M"),", SD = ", do_summary(k$iadl, 2, "SD"))
  # Return:
  k
}
