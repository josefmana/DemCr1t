#' Prepare a list of algorithms stratified by IADL mesure
#'
#' Using the table with PDD rates estimates per diagnostic algorithm,
#' this function extracts a list of algorithms using different IADL
#' criteria for PDD. If there was an algorithm that uses both criteria
#' at the same time, the function prints an error.
#'
#' @param algorithms A tibble containing raw summaries of PDD rates as
#'    generated by \code{summarise_rates}.
#' @param concordance description
#'
#' @returns A list with two components:
#' \describe{
#'   \item{\code{faq_tot}}{A numeric vector containing all Cohen's kappas
#'   of algorithm pairs with IADL deficit defined as FAQ total > 7.}
#'   \item{\code{faq_9}}{A numeric vector containing all Cohen's kappas
#'   of algorithm pairs with IADL deficit defined as FAQ item 9 > 1.}
#'   \item{\code{cross}}{A numeric vector containing all Cohen's kappas
#'   of algorithm pairs with different IADL deficit definitions.}
#'   \item{\code{iadl}}{A numeric vector containing all Cohen's kappas
#'   of algorithm pairs which differ only in IADL deficit definition.}
#'   \item{\code{sums}}{A named character vector containing mean and
#'   standard deviation of each vector of Kappas contained in this list.}
#' }
#'
#' @export
summarise_kappa <- function(algorithms, concordance) {
  # Prepare combinations within IADL operationalisation:
  k <- lapply(rlang::set_names(names(algorithms)), function(o) {
    combn(algorithms[[o]], 2) |>
      t() |>
      tibble::as_tibble() |>
      `colnames<-`(c("predictor", "reference")) |>
      dplyr::left_join(concordance, by = dplyr::join_by(predictor, reference)) |>
      dplyr::pull(Kappa_raw)
  })
  # Add cross-operationalisation cases:
  k$cross <- subset(concordance, predictor %in% algorithms$faq_9 & reference %in% algorithms$faq_tot)$Kappa_raw
  # Add Kappa summaries of algorithms with same everything but different IADL:
  k$iadl <- data.frame(
    predictor = c("Lvl.II (1)", "MMSE (1)", "MMSE (3)", paste0("MoCA (", seq(1, 59, 2),")"), "sMoCA (1)"),
    reference = c("Lvl.II (2)", "MMSE (2)", "MMSE (4)", paste0("MoCA (", seq(2, 60, 2),")"), "sMoCA (2)")
  ) |>
    dplyr::left_join(concordance, by = dplyr::join_by(predictor, reference)) |>
    dplyr::pull(Kappa_raw)
  # Extract Kappa summaries:
  k$sums <- sapply(names(k), function(i) {
    paste0(do_summary(k[[i]], 2, "M"),", SD = ", do_summary(k[[i]], 2, "SD"))
  })
  # Add summaries of Kappas:
  k$sums["iadl"] <- paste0(do_summary(k$iadl, 2, "M"),", SD = ", do_summary(k$iadl, 2, "SD"))
  # Return:
  k
}
