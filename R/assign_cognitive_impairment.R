#' Assign Cognitive Impairment Status
#'
#' Applies cognitive impairment classification based on z-scores computed via the normative
#' regression calculator from Bezdicek et al. [(2017)](https://doi.org/10.1080/13854046.2017.1293161),
#' following Level II PD-MCI criteria proposed by Litvan et al. [(2012)](https://doi.org/10.1002/mds.24893).
#' A patient is classified as cognitively impaired if they have two or more test scores with z < -1.5.
#'
#' @param d0 A list of data, typically generated by \code{prepare_data}, containing test scores.
#' @param calc A character string specifying the file path to the regression calculator
#'    (.xlsx format).
#' @param map A data frame, tibble, or matrix with:
#'   \itemize{
#'     \item Column 1: Label used in the calculator file
#'     \item Column 2: Corresponding label in the data
#'     \item Column 3: Cognitive domain of the test
#'     \item Column 4: Indicator of score direction (1 for normal, -1 if reversed)
#'   }
#'   Alternatively, a semicolon-delimited CSV file path containing such a table.
#' @param output A character string specifying the output format:
#'   \itemize{
#'     \item \code{"ci"} – return only a logical indicator of cognitive impairment
#'     \item \code{"z"} – return only z-scores for each index
#'     \item \code{"both"} – return both (default)
#'   }
#'
#' @returns Depending on the \code{output} argument:
#'   \describe{
#'     \item{\code{"ci"}}{A logical vector indicating cognitive impairment (`TRUE`/`FALSE`).}
#'     \item{\code{"z"}}{A data frame of computed z-scores per cognitive test.}
#'     \item{\code{"both"}}{A data.frame containing both \code{z} (z-scores) and \code{ci}
#'     (impairment status).}
#'   }
#'
#' @seealso [prepare_data()] is a wrapper of this function.
#'
#' @references
#' Bezdicek, O., Sulc, Z., Nikolai, T., Stepankova, H., Kopecek, M., Jech, R., & Růžička, E. (2017).
#' A parsimonious scoring and normative calculator for the Parkinson’s disease mild cognitive
#' impairment battery. *The Clinical Neuropsychologist, 31*(6-7), 1231-1247.
#' \doi{10.1080/13854046.2017.1293161}
#'
#' Litvan, I., Goldman, J. G., Tröster, A. I., Schmand, B. A., Weintraub, D., Petersen, R. C.,
#' ... & Emre, M. (2012). Diagnostic criteria for mild cognitive impairment in Parkinson's disease:
#' Movement Disorder Society Task Force guidelines. *Movement disorders, 27*(3), 349-356.
#' \doi{10.1002/mds.24893}
#'
#' @examples
#' \dontrun{
#' ci <- assign_cognitive_impairment(
#'   data,
#'   here::here("data-raw", "LevelIICalculator.xlsx"),
#'   here::here("data-raw", "CalculatorMapping.csv")
#' )
#' }
#'
#' @export
assign_cognitive_impairment <- function(d0, calc, map, output = "both") {
  # Read map if it is a file
  if (is.character(map)) {
    m <- readr::read_delim(map, delim = ";", col_types = readr::cols())
  } else {
    m <- map
  }
  # Read regression calculator file:
  r <- readxl::read_excel(calc, sheet = "equations", skip = 1) |>
    dplyr::rename("calc_lab" = "...1") |>
    dplyr::right_join(m, by = "calc_lab")
  # Prepare thresholds for BNT-60:
  bnt_thresh <- data.frame(
    age_bottom = c(0, 0, 60, 60),
    age_top    = c(60, 60, Inf, Inf),
    edu_bottom = c(0, 12, 0, 12),
    edu_top    = c(12, Inf, 12, Inf),
    threshold  = c(49, 52, 50, 53)
  )
  # Add CI-related values to data:
  d1 <- d0 |>
    dplyr::mutate(
      gender = as.numeric(sex) - 1, # to get man = 1, women = 0
      dplyr::across(
        .cols = tidyselect::all_of(r$data_lab),
        .fns = \(x) compute_z_score(r, x, r$calc_lab[r$data_lab == dplyr::cur_column()], age, gender, edu_years),
        .names = "z_{.col}"
      ),
      dplyr::across(
        .cols = tidyselect::starts_with("z_"),
        .fns = \(x) dplyr::if_else(x <= -1.5, 1, 0),
        .names = "mci_{.col}"
      ),
      # Re-score BNT because the calculator is for BNT-30 not -60
      mci_z_bnt_60 = sapply(seq_along(mci_z_bnt_60), function(i) {
        ifelse(
          test = is.na(age[i]) || is.na(edu_years[i]), # To ensure correct format.
          yes = NA,
          no = dplyr::if_else(
            bnt_60[i] <= with(bnt_thresh, threshold[age[i] > age_bottom & age[i] <= age_top & edu_years[i] > edu_bottom & edu_years[i] <= edu_top]),
            true  = 1,
            false = 0
          )
        )
      })
    ) |>
    dplyr::select(id, tidyselect::starts_with("z_"), tidyselect::starts_with("mci_"), -z_bnt_60) |>
    dplyr::rename_all(\(x) sub("mci_z", "mci", x)) |>
    dplyr::mutate(
      flags = rowSums(dplyr::across(tidyselect::starts_with("mci_")), na.rm = TRUE),
      nas =
        rowSums(is.na(dplyr::across(tidyselect::starts_with("mci_")))) -
        dplyr::if_else(rowSums(is.na(dplyr::across(tidyselect::all_of(c("mci_wms_family_30", "mci_bvmt_30"))))) < 2, 1, 0), # Only one of these need to be present.
      CI = dplyr::case_when(
        flags >= 2 ~ 1,
        flags == 0 & nas < 2 ~ 0,
        flags == 1 & nas == 0 ~ 0,
        .default = NA
      ),
      nonCI = 1 - CI
    )
  # Return conditionally on selection:
  if (output == "ci") {
    d1 |> dplyr::select(id, CI, nonCI)
  } else if (output == "z") {
    d1 |> dplyr::select(id, starts_with("z_"))
  } else if (output == "both") {
    d1
  }
}
