#' Assigns cognitive impairment status (roughly)
#' according to Bezdicek et al.'s (2017) normative
#' calculator.
#'
#' This function takes in patient data with columns
#' containing PD-MCI battery at level II according
#' to Litvan et al. (2012) and especially Bezdicek
#' et al. (2017); mapping of columns to test indexes;
#' and path to regression calculator in .xlsx. It
#' then applies the calculator to data to arrive at
#' z-scores and labels cognitive impairment as
#' performance with 2 or more z < -1.5 as per citations
#' above.
#'
#' @param d0 A list of data generated by \code{prepare_data}.
#' @param calc A character containing path to the regression
#' calculator table.
#' @param map A data.frame/tibble/matrix with the first column
#' denoting label in the calculator file, the second column
#' denoting label in data, the third column denoting cognitive
#' domain of the test index and the fourth column denoting
#' whether the score is reversed (-1) or not (1).
#' Alternatively, a path to a .csv delimited by semi-colon
#' containing such a table.
#' @param output A character indicating whether only
#' an indicator of cognitive impairment ought to be
#' returned ("ci"), only z-scores ought to be returned
#' ("z") or both ("both", default).
#'
#' @returns
#'
#' @examples
#' \dontrun{
#' ci <- assign_cognitive_impairment(
#'   data,
#'   here::here("data-raw", "LevelIICalculator.xlsx"),
#'   here::here("data-raw", "CalculatorMapping.csv")
#' )
#'
#' }
#' @export
assign_cognitive_impairment <- function(d0, calc, map, output = "both") {
  # Read map if it is a file
  if(is.character(map)) {
    m <- readr::read_delim(map, delim = ';', col_types = cols())
  } else {
    m <- map
  }
  # Read regression calculator file:
  r <-
    readxl::read_excel(calc, sheet = "equations", skip = 1) |>
    rename("calc_lab" = "...1") |>
    right_join(m, by = "calc_lab")
  # Prepare thresholds for BNT-60:
  bnt_thresh <-
    data.frame(
      age_bottom = c(0, 0, 60, 60),
      age_top    = c(60, 60, Inf, Inf),
      edu_bottom = c(0, 12, 0, 12),
      edu_top    = c(12, Inf, 12, Inf),
      threshold  = c(49, 52, 50, 53)
    )
  # Add CI-related values to data:
  d1 <-
    d0 |>
    mutate(
      gender = as.numeric(sex)-1, # to get man = 1, women = 0
      across(
        .cols  = all_of(r$data_lab),
        .fns   = ~compute_z_score(r, .x, r$calc_lab[r$data_lab == cur_column()], age, gender, edu_years),
        .names = "z_{.col}"
      ),
      across(
        .cols  = starts_with("z_"),
        .fns   = ~if_else(.x <= -1.5, 1, 0),
        .names = "mci_{.col}"
      ),
      mci_z_bnt_60 = # Re-score BNT because the calculator is for BNT-30 not -60
        sapply(
          seq_len(length(mci_z_bnt_60)),
          function(i)
            ifelse(
              test = is.na(age[i]) || is.na(edu_years[i]), # To ensure correct format.
              yes = NA,
              no = if_else(
                bnt_60[i] <= with(bnt_thresh, threshold[age[i] > age_bottom & age[i] <= age_top & edu_years[i] > edu_bottom & edu_years[i] <= edu_top]),
                true  = 1,
                false = 0
              )
            )

      )
    ) |>
    select(id, starts_with("z_"), starts_with("mci_"), -z_bnt_60) |>
    rename_all(~sub("mci_z", "mci", .x)) |>
    mutate(
      flags = rowSums(across(starts_with("mci_")), na.rm = T),
      nas   =
        rowSums(is.na(across(starts_with("mci_")))) -
        if_else(rowSums(is.na(across(all_of(c("mci_wms_family_30", "mci_bvmt_30"))))) < 2, 1, 0), # Only one of these need to be present.
      CI    = case_when(
        flags >= 2 ~ 1,
        flags == 0 & nas < 2 ~ 0,
        flags == 1 & nas == 0 ~ 0,
        .default = NA
      ),
      nonCI = 1-CI
    )
  # Return conditionally on selection:
  if(output == "ci") {
    d1 |> select(id, CI, nonCI)
  } else if(output == "z") {
    d1 |> select(id, starts_with("z_"))
  } else if(output == "both") {
    d1
  }
}
