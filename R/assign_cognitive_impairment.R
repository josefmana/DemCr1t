#' Assign cognitive impairment status using Bezdicek et al.'s (2017) normative calculator
#'
#' Applies cognitive impairment classification based on z-scores computed via the normative
#' regression calculator from Bezdicek et al. (2017), following Level II PD-MCI criteria
#' proposed by Litvan et al. (2012). A patient is classified as cognitively impaired if they
#' have two or more test scores with z < -1.5.
#'
#' @param d0 A list of data, typically generated by \code{prepare_data}, containing test scores.
#' @param calc A character string specifying the file path to the regression calculator
#' (.xlsx format).
#' @param map A data frame, tibble, or matrix with:
#'   \itemize{
#'     \item Column 1: Label used in the calculator file
#'     \item Column 2: Corresponding label in the data
#'     \item Column 3: Cognitive domain of the test
#'     \item Column 4: Indicator of score direction (1 for normal, -1 if reversed)
#'   }
#'   Alternatively, a semicolon-delimited CSV file path containing such a table.
#' @param output A character string specifying the output format:
#'   \itemize{
#'     \item \code{"ci"} – return only a logical indicator of cognitive impairment
#'     \item \code{"z"} – return only z-scores for each index
#'     \item \code{"both"} – return both (default)
#'   }
#'
#' @returns Depending on the \code{output} argument:
#'   \describe{
#'     \item{\code{"ci"}}{A logical vector indicating cognitive impairment (TRUE/FALSE).}
#'     \item{\code{"z"}}{A data frame of computed z-scores per cognitive test.}
#'     \item{\code{"both"}}{A list with two elements: \code{z} (z-scores) and \code{ci} (impairment status).}
#'   }
#'
#' @examples
#' \dontrun{
#' ci <- assign_cognitive_impairment(
#'   data,
#'   here::here("data-raw", "LevelIICalculator.xlsx"),
#'   here::here("data-raw", "CalculatorMapping.csv")
#' )
#' }
#'
#' @export
assign_cognitive_impairment <- function(d0, calc, map, output = "both") {
  # Read map if it is a file
  if(is.character(map)) {
    m <- readr::read_delim(map, delim = ";", col_types = cols())
  } else {
    m <- map
  }
  # Read regression calculator file:
  r <-
    readxl::read_excel(calc, sheet = "equations", skip = 1) |>
    rename("calc_lab" = "...1") |>
    right_join(m, by = "calc_lab")
  # Prepare thresholds for BNT-60:
  bnt_thresh <-
    data.frame(
      age_bottom = c(0, 0, 60, 60),
      age_top    = c(60, 60, Inf, Inf),
      edu_bottom = c(0, 12, 0, 12),
      edu_top    = c(12, Inf, 12, Inf),
      threshold  = c(49, 52, 50, 53)
    )
  # Add CI-related values to data:
  d1 <-
    d0 |>
    mutate(
      gender = as.numeric(sex)-1, # to get man = 1, women = 0
      across(
        .cols  = all_of(r$data_lab),
        .fns   = ~compute_z_score(r, .x, r$calc_lab[r$data_lab == cur_column()], age, gender, edu_years),
        .names = "z_{.col}"
      ),
      across(
        .cols  = starts_with("z_"),
        .fns   = ~if_else(.x <= -1.5, 1, 0),
        .names = "mci_{.col}"
      ),
      mci_z_bnt_60 = # Re-score BNT because the calculator is for BNT-30 not -60
        sapply(
          seq_len(length(mci_z_bnt_60)),
          function(i)
            ifelse(
              test = is.na(age[i]) || is.na(edu_years[i]), # To ensure correct format.
              yes = NA,
              no = if_else(
                bnt_60[i] <= with(bnt_thresh, threshold[age[i] > age_bottom & age[i] <= age_top & edu_years[i] > edu_bottom & edu_years[i] <= edu_top]),
                true  = 1,
                false = 0
              )
            )

      )
    ) |>
    select(id, starts_with("z_"), starts_with("mci_"), -z_bnt_60) |>
    rename_all(~sub("mci_z", "mci", .x)) |>
    mutate(
      flags = rowSums(across(starts_with("mci_")), na.rm = TRUE),
      nas   =
        rowSums(is.na(across(starts_with("mci_")))) -
        if_else(rowSums(is.na(across(all_of(c("mci_wms_family_30", "mci_bvmt_30"))))) < 2, 1, 0), # Only one of these need to be present.
      CI    = case_when(
        flags >= 2 ~ 1,
        flags == 0 & nas < 2 ~ 0,
        flags == 1 & nas == 0 ~ 0,
        .default = NA
      ),
      nonCI = 1-CI
    )
  # Return conditionally on selection:
  if(output == "ci") {
    d1 |> select(id, CI, nonCI)
  } else if(output == "z") {
    d1 |> select(id, starts_with("z_"))
  } else if(output == "both") {
    d1
  }
}
